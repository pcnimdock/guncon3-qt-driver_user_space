#include "guncon_usb.h"

const unsigned char key[8]={0x01,0x12,0x6f,0x32,0x24,0x60,0x17,0x21};

guncon_usb::guncon_usb(QObject *parent) : QObject(parent)
{
    QByteArray send, recv;
    send.clear();
    send.append((char*)(key),8);
    this->setupDevice();
    if (this->openDevice()) {
      qDebug("Device open!");
      opened=1;
      this->write(&send);
//      this->read(&recv);
    }
    else
    {
        opened=0;
    }
}

guncon_usb::~guncon_usb()
{

}

void guncon_usb::setupDevice()
{
    /* There are 2 ways of identifying devices depending on the platform.
     * You can use both methods, only one will be taken into account.
     */

    mUsbDev = new QUsbDevice();
    mUsbDev->setDebug(true);
mUsbDev->setTimeout(USB_TIMEOUT_MSEC);
    //
    mFilter.pid = 0x0800;
    mFilter.vid = 0x0b9a;

    //
    mConfig.alternate = 0;
    mConfig.config = 1; // bConfigurationValue
    mConfig.interface = 0;
    mConfig.readEp = 0x82;  //EP 2 IN
    mConfig.writeEp = 0x02; //EP 2 OUT

}




bool guncon_usb::openDevice()
{
    qDebug("Opening");

    QtUsb::DeviceStatus ds;
    ds = mUsbManager.openDevice(mUsbDev, mFilter, mConfig);

    if (ds == QtUsb::deviceOK) {
      // Device is open
      return true;
    }
    return false;
}

bool guncon_usb::closeDevice()
{
    qDebug("Closing");
    mUsbManager.closeDevice(mUsbDev);
    return false;
}

qint16 guncon_usb::read(QByteArray *buf)
{ return(mUsbDev->read(buf, 15)); }

void guncon_usb::write(QByteArray *buf) { mUsbDev->write(buf, buf->size()); }



static const unsigned char KEY_TABLE[320] = {
    0x75, 0xC3, 0x10, 0x31, 0xB5, 0xD3, 0x69, 0x84, 0x89, 0xBA, 0xD6, 0x89, 0xBD, 0x70, 0x19, 0x8E, 0x58, 0xA8,
    0x3D, 0x9B, 0x5D, 0xF0, 0x49, 0xE8, 0xAD, 0x9D, 0x7A, 0xD, 0x7E, 0x24, 0xDA, 0xFC, 0xD, 0x14, 0xC5, 0x23,
    0x91, 0x11, 0xF5, 0xC0, 0x4B, 0xCD, 0x44, 0x1C, 0xC5, 0x21, 0xDF, 0x61, 0x54, 0xED, 0xA2, 0x81, 0xB7, 0xE5,
    0x74, 0x94, 0xB0, 0x47, 0xEE, 0xF1, 0xA5, 0xBB, 0x21, 0xC8, 0x91, 0xFD, 0x4C, 0x8B, 0x20, 0xC1, 0x7C, 9, 0x58,
    0x14, 0xF6, 0, 0x52, 0x55, 0xBF, 0x41, 0x75, 0xC0, 0x13, 0x30, 0xB5, 0xD0, 0x69, 0x85, 0x89, 0xBB, 0xD6, 0x88,
    0xBC, 0x73, 0x18, 0x8D, 0x58, 0xAB, 0x3D, 0x98, 0x5C, 0xF2, 0x48, 0xE9, 0xAC, 0x9F, 0x7A, 0xC, 0x7C, 0x25, 0xD8,
    0xFF, 0xDC, 0x7D, 8, 0xDB, 0xBC, 0x18, 0x8C, 0x1D, 0xD6, 0x3C, 0x35, 0xE1, 0x2C, 0x14, 0x8E, 0x64, 0x83, 0x39,
    0xB0, 0xE4, 0x4E, 0xF7, 0x51, 0x7B, 0xA8, 0x13, 0xAC, 0xE9, 0x43, 0xC0, 8, 0x25, 0xE, 0x15, 0xC4, 0x20, 0x93,
    0x13, 0xF5, 0xC3, 0x48, 0xCC, 0x47, 0x1C, 0xC5, 0x20, 0xDE, 0x60, 0x55, 0xEE, 0xA0, 0x40, 0xB4, 0xE7, 0x74,
    0x95, 0xB0, 0x46, 0xEC, 0xF0, 0xA5, 0xB8, 0x23, 0xC8, 4, 6, 0xFC, 0x28, 0xCB, 0xF8, 0x17, 0x2C, 0x25, 0x1C,
    0xCB, 0x18, 0xE3, 0x6C, 0x80, 0x85, 0xDD, 0x7E, 9, 0xD9, 0xBC, 0x19, 0x8F, 0x1D, 0xD4, 0x3D, 0x37, 0xE1, 0x2F,
    0x15, 0x8D, 0x64, 6, 4, 0xFD, 0x29, 0xCF, 0xFA, 0x14, 0x2E, 0x25, 0x1F, 0xC9, 0x18, 0xE3, 0x6D, 0x81, 0x84,
    0x80, 0x3B, 0xB1, 0xE5, 0x4D, 0xF7, 0x51, 0x78, 0xA9, 0x13, 0xAD, 0xE9, 0x80, 0xC1, 0xB, 0x25, 0x93, 0xFC,
    0x4D, 0x89, 0x23, 0xC2, 0x7C, 0xB, 0x59, 0x15, 0xF6, 1, 0x50, 0x55, 0xBF, 0x81, 0x75, 0xC3, 0x10, 0x31, 0xB5,
    0xD3, 0x69, 0x84, 0x89, 0xBA, 0xD6, 0x89, 0xBD, 0x70, 0x19, 0x8E, 0x58, 0xA8, 0x3D, 0x9B, 0x5D, 0xF0, 0x49,
    0xE8, 0xAD, 0x9D, 0x7A, 0xD, 0x7E, 0x24, 0xDA, 0xFC, 0xD, 0x14, 0xC5, 0x23, 0x91, 0x11, 0xF5, 0xC0, 0x4B, 0xCD,
    0x44, 0x1C, 0xC5, 0x21, 0xDF, 0x61, 0x54, 0xED, 0xA2, 0x81, 0xB7, 0xE5, 0x74, 0x94, 0xB0, 0x47, 0xEE, 0xF1,
    0xA5, 0xBB, 0x21, 0xC8
};

QByteArray guncon_usb::decode(QByteArray data2)
{
    QByteArray ret;
    ret.clear();
    int x, y, key_index;
    int bkey, keyr, byte;
    int a_sum,b_sum;
    int key_offset;
    unsigned char data[15];
    if(data2.size()!=15)
    {return ret;}
    for(int i=0;i<15;i++)
    {
        data[i]=data2[i];
    }

        b_sum = data[13] ^ data[12];
        b_sum = b_sum + data[11] + data[10] - data[9] - data[8];
        b_sum = b_sum ^ data[7];
        b_sum = b_sum & 0xFF;
        a_sum = data[6] ^ b_sum;
        a_sum = a_sum - data[5] - data[4];
        a_sum = a_sum ^ data[3];
        a_sum = a_sum + data[2] + data[1] - data[0];
        a_sum = a_sum & 0xFF;

        if (a_sum != key[7]) {
        if (1)
            qDebug() << "checksum mismatch: ";
        return NULL;
    }

    //key_offset = (((((key[1] ^ key[2]) - key[3] - key[4]) ^ key[5]) + key[6] - key[7]) ^ data[14]) + (unsigned char)0x26;
        key_offset = key[1] ^ key[2];
          key_offset = key_offset - key[3] - key[4];
          key_offset = key_offset ^ key[5];
          key_offset = key_offset + key[6] - key[7];
          key_offset = key_offset ^ data[14];
          key_offset = key_offset + 0x26;
          key_offset = key_offset & 0xFF;

    key_index = 4;

    //byte E is part of the key offset
    // byte D is ignored, possibly a padding byte - make the checksum workout
    for (x = 12; x >= 0; x--) {
        byte = data[x];
        for (y = 4; y > 1; y--) { // loop 3 times
            key_offset--;

            bkey = KEY_TABLE[key_offset + 0x41];
            keyr = key[key_index];
            if (--key_index == 0)
                key_index = 7;

            if ((bkey & 3) == 0)
                byte =(byte - bkey) - keyr;
            else if ((bkey & 3) == 1)
                byte = ((byte + bkey) + keyr);
            else
                byte = ((byte ^ bkey) ^ keyr);
        }
        ret.append(byte);
    }
    return ret;

}

bool guncon_usb::isOpen()
{
    return(opened);

}

void guncon_usb::new_read()
{
    QByteArray buf;qint16 num_bytes;
    num_bytes=this->read(&buf);
    //qDebug() << "Num bytes readed " << QString::number(num_bytes);
    if(num_bytes<0){buf.clear();}
    emit(new_readed_data(buf));

}
